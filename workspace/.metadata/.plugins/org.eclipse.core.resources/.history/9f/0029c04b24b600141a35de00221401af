// demonstrate how to display an image

import java.awt.*;
import java.io.File;
import java.util.Random;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.*;

import javax.swing.*;

public class TextureGen extends JPanel implements ActionListener {
	// private static BufferedImage inputImage; // image object of input image
	private static BufferedImage embossColorImage; // grey image of input image

	private short[][] red; // array of red which is extracted from the image data
	private short[][] green; // array of green which is extracted from the image data
	private short[][] blue; // array of blue which is extracted from the image data
	private int[] sourceImageData; // data array of input image
	private int rows; // image height
	private int cols; // image width
	int M, N; /* power of 2 for each dimension */
	Timer t = new Timer(20,this);
	BufferedImage sourceImage = null, textureImage = null;
	int i = 0;
	short[]colour = {0,0,0};
	int w = 0;
	File sourceFile, savedFile;
	int iWidth, iHeight, tWidth, tHeight;
	String sWidth, sHeight;
	Boolean dir = true;

	static JSlider redSlider = new JSlider(JSlider.HORIZONTAL, (int) 0f,
			(int) 254f, (int) 0f);

	public TextureGen() // throws Exception
	{

		sourceImage = textureImage = embossColorImage = ImageUtilities
				.getBufferedImage("Aber.gif", this);
		iWidth = sourceImage.getWidth();
		iHeight = sourceImage.getHeight();

		sWidth = Integer.toString(iWidth);
		sHeight = Integer.toString(iHeight);

		loadRGBArrays();
		makeBlank();
		
		repaint();
		t.start();
		
	}

	public void paint(Graphics g) {

		g.drawImage(sourceImage, 50, 30, this); // original image
		g.drawImage(embossColorImage, 70 + iWidth, 30, this); // convolved image
	}

	/*
	 * taken from an example by yyl
	 */
	public void loadRGBArrays() {
		// check if we need to resize the component arrays, i.e.,
		// has the size of the image changed?
		if (sourceImage.getHeight() != rows || sourceImage.getWidth() != cols) {
			rows = sourceImage.getHeight();
			cols = sourceImage.getWidth();

			red = new short[rows][cols];
			green = new short[rows][cols];
			blue = new short[rows][cols];
		}

		// get pixels as ints of the form 0xRRGGBB
		sourceImageData = sourceImage.getRGB(0, 0, sourceImage.getWidth(),
				sourceImage.getHeight(), null, 0, sourceImage.getWidth());

		// extract red, green, and blue components from each pixel
		int index;
		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < cols; col++) {
				index = (row * cols) + col;
				unpackPixel(sourceImageData[index], red, green, blue, row, col);
			}
		}
	}

	public BufferedImage makeNewBufferedImage(short[][] ImageDataRed,
			short[][] ImageDataGreen, short[][] ImageDataBlue) {
		int[] newBufferedImageData = new int[rows * cols];
		int index;
		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < cols; col++) {
				index = (row * cols) + col;
				newBufferedImageData[index] = packPixel(ImageDataRed[row][col],
						ImageDataGreen[row][col], ImageDataBlue[row][col]);
			}
		}

		BufferedImage newImage = new BufferedImage(cols, rows,
				BufferedImage.TYPE_INT_RGB);

		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < cols; col++) {
				index = (row * cols) + col;
				newImage.setRGB(col, row, newBufferedImageData[index]);
			}
		}

		return newImage;
	}

	private static int packPixel(int red, int green, int blue) {
		return (red << 16) | (green << 8) | blue;
	}

	private static void unpackPixel(int pixel, short[][] red, short[][] green,
			short[][] blue, int row, int col) {
		red[row][col] = (short) ((pixel >> 16) & 0xFF);
		green[row][col] = (short) ((pixel >> 8) & 0xFF);
		blue[row][col] = (short) ((pixel >> 0) & 0xFF);
	}


	public void makeBlank() {
		loadRGBArrays();
		for (int row = 0; row < rows; row++) {
			for (int col = 0; col < cols; col++) {

				red[row][col] = 0;
				green[row][col] = 0;
				blue[row][col] = 0;

			}

		}

		embossColorImage = makeNewBufferedImage(red, green, blue);
		repaint();
	}
	
	
	public void DrawCircle(int x0, int y0, int radius, short[] colour)
	{
	  int x = radius;
	  int y = 0;
	  int radiusError = 1-x;
	 
	  while(x >= y)
	  {
	    DrawPixel(x + x0, y + y0, colour);
	    DrawPixel(y + x0, x + y0, colour);
	    DrawPixel(-x + x0, y + y0, colour);
	    DrawPixel(-y + x0, x + y0, colour);
	    DrawPixel(-x + x0, -y + y0, colour);
	    DrawPixel(-y + x0, -x + y0, colour);
	    DrawPixel(x + x0, -y + y0, colour);
	    DrawPixel(y + x0, -x + y0, colour);
	    y++;
	    if (radiusError<0)
	    {
	      radiusError += 2 * y + 1;
	    }
	    else
	    {
	      x--;
	      radiusError += 2 * (y - x) + 1;
	    }
	  }
	  
	  embossColorImage = makeNewBufferedImage(red, green, blue);
		repaint();
	}
	
	public void DrawPixel (int x, int y, short[] colour){
		
		red[x][y] = colour[0];
		green[x][y] = colour[1];
		blue[x][y] = colour[2];

		
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		// TODO Auto-generated method stub
		
		if(i == 765){
			dir = false;
		} else {
			dir = true;
		}
		
		if(dir){
			i++;
		}else {
			i--;
		}
			
			if(colour[0] >= 255 && colour[1] != 255){
				colour[1]++;
			} else if(colour[1] >= 255 && colour[2] != 255){
				colour[2]++;
			} else {
				colour[0] ++;
			}
			
			if(w == (rows/2)- 1){
				w=0;
			}else {
			w++;
			}
			
			DrawCircle(rows/2,cols/2, w, colour);
			repaint();
		}
		
	}